# SConstuct
# for PDB
# created on: 12/04/2015

import os
import re
import platform
import multiprocessing
import glob
from os import path

common_env = Environment(CXX = 'clang++')
#common_env.Append(YACCFLAGS='-d')
common_env.Append(CFLAGS='-std=c11')

# the following variables are used for output coloring to see errors and warnings better.
common_env = Environment(ENV = {'PATH' : os.environ['PATH'],
                         'TERM' : os.environ['TERM'],
                         'HOME' : os.environ['HOME']})
SRC_ROOT = os.path.join(Dir('.').abspath, "src") # assume the root source dir is in the working dir named as "src"

# OSX settings
if common_env['PLATFORM'] == 'darwin':
    print 'Compiling on OSX'
    common_env.Append(CXXFLAGS = '-std=c++1y -Wall -O0 -g')
    common_env.Replace(CXX = "clang++")

# Linux settings
elif  common_env['PLATFORM'] == 'posix':
    print 'Compiling on Linux'
    common_env.Append(LIBS = ['-lprotobuf', '-lboost_serialization'])
    common_env.Append(CXXFLAGS = '-std=c++11  -O3 -march=native ')
    common_env.Append(LINKFLAGS = '-std=c++11 -lprotobuf -pthread -lpthread  -lboost_serialization')
    common_env.Replace(CXX = "g++")

common_env.Append(CCFLAGS='-DINITIALIZE_ALLOCATOR_BLOCK')
common_env.Append(CCFLAGS='-DENABLE_SHALLOW_COPY')
common_env.Append(CCFLAGS='-DDEFAULT_BATCH_SIZE=100')
common_env.Append(CCFLAGS='-DREMOVE_SET_WITH_EVICTION')
#common_env.Append(CCFLAGS='-DCLEAR_SET')
#common_env.Append(CCFLAGS='-DPDB_DEBUG')
#common_env.Append(CCFLAGS='-DEVICT_STOP_THRESHOLD=0.9')
# Make the build multithreaded
num_cpu = int(multiprocessing.cpu_count())
SetOption('num_jobs', num_cpu)

# two code files that will be included by the VTableMap to pre-load all of the
# built-in object types into the map
objectTargetDir = os.path.join(SRC_ROOT, 'objectModel', 'headers')
def writeIncludeFile(includes):
	#
	# print objectTargetDir + 'BuiltinPDBObjects.h'
	#
	# this is the file where the produced list of includes goes
	includeFile = open(os.path.join(objectTargetDir, 'BuiltinPDBObjects.h'), 'w+')
	includeFile.write ("// Auto-generated by code in SConstruct\n")
	for fileName in includes:
		includeFile.write ('#include "' + fileName + '"\n')

def writeCodeFile(classes):
	#
	# this is the file where the produced code goes
	codeFile = open(os.path.join(objectTargetDir,'BuiltinPDBObjects.cc'), 'w+')
	codeFile.write ("// Auto-generated by code in SConstruct\n\n")
	codeFile.write ("// first, record all of the type codes\n")

	for counter, classname in enumerate(classes, 1):
		codeFile.write ('objectTypeNamesList [getTypeName <' + classname + '> ()] = ' + str(counter) + ';\n')

	codeFile.write ('\n// now, record all of the vTables\n')

	for counter, classname in enumerate(classes, 1):
		codeFile.write ('{\n\tconst UseTemporaryAllocationBlock tempBlock{1024 * 24};');
		codeFile.write ('\n\ttry {\n\t\t')
		codeFile.write (classname + ' tempObject;\n')
		codeFile.write ('\t\tallVTables [' + str(counter) + '] = tempObject.getVTablePtr ();\n')
		codeFile.write ('\t} catch (NotEnoughSpace &e) {\n\t\t')
		codeFile.write ('std :: cout << "Not enough memory to allocate ' + classname + ' to extract the vTable.\\n";\n\t}\n}\n\n');

def writeTypeCodesFile(classes):
	#
	# this is the file where all of the built-in type codes goes
	typeCodesFile = open(os.path.join(objectTargetDir, 'BuiltInObjectTypeIDs.h'), 'w+')
	typeCodesFile.write ("// Auto-generated by code in SConstruct\n")
 	typeCodesFile.write ('#define NoMsg_TYPEID 0\n')

	for counter, classname in enumerate(classes, 1):
		pattern = re.compile('\<[\w\s\<\>]*\>')
		if pattern.search (classname):
			templateArg = pattern.search (classname)
			classname = classname.replace (templateArg.group (), "").strip ()
			#
		# Remove the namespace if any
		classname = classname.rsplit("::")[-1]
		typeCodesFile.write('#define ' + classname + '_TYPEID ' + str(counter) + '\n')

def writeFiles(includes, classes):
	writeIncludeFile(includes)
	writeCodeFile(classes)
	writeTypeCodesFile(classes)

def scanClassNames(includes):
	for counter, fileName in enumerate(includes, 1):
		datafile = file(fileName)
		# search for a line like:
		# // PRELOAD %ObjectTwo%
		p = re.compile('//\s*PRELOAD\s*%[\w\s\<\>]*%')
		for line in datafile:
			# if we found the line
			if p.search(line):
				# extract the text between the two '%' symbols
				m = p.search(line)
				instance = m.group ()
				p = re.compile('%[\w\s\<\>]*%')
				m = p.search(instance)
				yield (m.group ())[1:-1]

def extractCode (common_env, targets, sources, extra_includes=[], extra_classes=[]):
    # Sort the class names so that we have consistent type ids
	scanned = list(scanClassNames(sources))
	scanned.sort()
	writeFiles(
		includes=map(path.abspath, list(extra_includes)) + sources,
		classes=list(extra_classes) + scanned)

# here we get a list of all of the .h files in the 'headers' directory
from os import listdir
from os.path import isfile, isdir, join, abspath
objectheaders = os.path.join(SRC_ROOT, 'builtInPDBObjects', 'headers')





# Construct a dictionary where each key is the directory basename of a PDB system component folder and each value
# is a list of .cc files used to implement that component.
#
# Expects the path structure of .cc files to be: SRC_ROOT / [component name] / source / [ComponentFile].cc
#
# For example, the structure:
#
#   src/                 <--- assume SRC_ROOT is here
#       compA/
#           headers/
#           source/
#               file1.cc
#               file2.cc
#               readme.txt
#       compB/
#           headers/
#           source/
#               file3.cc
#               file4.cc
#
#
# would result in component_dir_basename_to_cc_file_paths being populated as:
#
#   {'compA':[SRC_ROOT + "/compA/source/file1.cc", SRC_ROOT + "/compA/source/file2.cc"],
#    'compB':[SRC_ROOT + "/compB/source/file3.cc", SRC_ROOT + "/compB/source/file3.cc"]}
#
# on a Linux system.
component_dir_basename_to_lexer_c_file_paths = dict ()
component_dir_basename_to_cc_file_paths = dict ()
component_dir_basename_to_lexer_file_paths = dict ()
src_root_subdir_paths = [path for path in  map(lambda s: join(SRC_ROOT, s), listdir(SRC_ROOT)) if isdir(path)]
for src_subdir_path in src_root_subdir_paths:

    source_folder = join(src_subdir_path, 'source/')
    if(not isdir(source_folder)): # if no source folder lives under the subdir_path, skip this folder
        continue

    src_subdir_basename = os.path.basename(src_subdir_path)

    # first, map build output folders (on the left) to source folders (on the right)
    if src_subdir_basename == 'logicalPlan':
        # maps .y and .l source files used by flex and bison
        lexerSources = [abspath(join(join (source_folder),f2)) for f2 in listdir(source_folder) if isfile(join(source_folder, f2)) and (f2[-2:] == '.y' or f2[-2:] == '.l')]
        component_dir_basename_to_lexer_file_paths [src_subdir_basename] = lexerSources
        
        # maps .cc source files
        common_env.VariantDir(join('build/', src_subdir_basename), [source_folder], duplicate = 0)        
        ccSources = [abspath(join(join ('build/', src_subdir_basename),f2)) for f2 in listdir(source_folder) if isfile(join(source_folder, f2)) and (f2[-3:] == '.cc') ]        

        component_dir_basename_to_cc_file_paths [src_subdir_basename] = ccSources

        # maps .c files        
        cSources = [(abspath(join(join ('build/', src_subdir_basename),'Parser.c'))), (abspath(join(join ('build/', src_subdir_basename),'Lexer.c')))]
        
        #component_dir_basename_to_lexer_c_file_paths [src_subdir_basename] = cSources
            
    else:
        common_env.VariantDir(join('build/', src_subdir_basename), [source_folder], duplicate = 0)

        # next, add all of the sources in
        allSources = [abspath(join(join ('build/', src_subdir_basename),f2)) for f2 in listdir(source_folder) if isfile(join(source_folder, f2)) and (f2[-3:] == '.cc' or f2[-2:] == '.y' or f2[-2:] == '.l')]
        component_dir_basename_to_cc_file_paths [src_subdir_basename] = allSources

# second, map build output folders (on the left) to source folders (on the right) for .so libraries
common_env.VariantDir('build/libraries/', 'src/sharedLibraries/source/', duplicate = 0)

# List of folders with headers
headerpaths = [abspath(join(join(SRC_ROOT, f), 'headers/')) for f in listdir(SRC_ROOT) if os.path.isdir (join(join(SRC_ROOT, f), 'headers/'))]



# Adds header folders and required libraries
common_env.Append(CPPPATH = headerpaths)

print 'Platform: ' + platform.platform()
print 'System: ' + platform.system()
print 'Release: ' + platform.release()
print 'Version: ' + platform.version()

                        
                          

all = [component_dir_basename_to_cc_file_paths['allocator'],
       component_dir_basename_to_cc_file_paths['datagen'],
       component_dir_basename_to_cc_file_paths['externalsort'],
       component_dir_basename_to_cc_file_paths['handcoded'],
       component_dir_basename_to_cc_file_paths['networkexp'],
       component_dir_basename_to_cc_file_paths['offsetptr'],
       component_dir_basename_to_cc_file_paths['protogen'],
       component_dir_basename_to_cc_file_paths['sockets'],
       component_dir_basename_to_cc_file_paths['testcases'],
       component_dir_basename_to_cc_file_paths['boost'], 
       component_dir_basename_to_cc_file_paths['filehandler'],
       component_dir_basename_to_cc_file_paths['inplace'],
       component_dir_basename_to_cc_file_paths['object'],
       component_dir_basename_to_cc_file_paths['protobuf'],
       component_dir_basename_to_cc_file_paths['rootdata'],
       component_dir_basename_to_cc_file_paths['sparsevector'],
       component_dir_basename_to_cc_file_paths['datareader'],
      ]


print(all)
# common_env.SharedLibrary('libraries/libSharedEmployee.so', ['build/libraries/SharedEmployee.cc'] + all)

common_env.Program('bin/datagen', ['build/datagen/DataGenerator.cc'] + all)

main=common_env.Alias('main', ['bin/datagen'])
Default(main)
